///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.05
///////////////////////////////////////////////////////////////////////////////
/***********************文件说明*****************
* 实现功能：读取当前工作路径下的temp//raw_img文件夹下的所有图片，并实现滤波、颜色空间变换、三种分量的阈值化
*			以及面积比率计算。输入任何大小的图片（不宜过大，否则会内存溢出），输出图片为原图片尺寸。测试通过
* 后缀说明：1.png 原图
			1_binaryThreshold_Hue_Blob_38%：对Hue分量做阈值化并进行Blob分析
			1_binaryThreshold_Intensity_Blob_54%：对Intensity分量做阈值化并进行Blob分析
			1_binaryThreshold_Saturation_Blob_12%：对Saturation分量做阈值化并进行Blob分析
			1_binaryThresholdMeanImage_54%：对滤波图像直接阈值化
			1_binaryThresholdMeanImage_WithBlob_54%：对滤波图像直接阈值化后并进行Blob分析
			1_gray_histogram：图像的灰度直方图
			1_meanImage：滤波后的图
			1_Hue:颜色空间变换后保存Hue分量
			1_Intensity:保存Intensity分量
			1_Saturation:保存Saturation分量
			最后的百分数表示识别区域占整张图像的比率
* 文件保存路径：当前工作路径下的//temp//processed_img文件下
* 函数说明：调用action()函数即可

**/
// strcpy 报错
#pragma warning(disable : 4996)

#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif

#include <iostream>
#include <string>
#include <vector>
#include <io.h>
#include <direct.h>
#include <atlconv.h>



using namespace HalconCpp;
using namespace std;
// 后缀内存分配长度0
#define lengthOfPost 50



// Procedure declarations 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off();
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
	HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld(HObject* ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
	HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);
// Local procedures 
void plot_histo(HTuple hv_Histogram, HTuple hv_WindowHandle, HTuple hv_LabelX, HTuple hv_ValueXMin,
	HTuple hv_ValueXMax, HTuple hv_ColorAxis, HTuple hv_ColorGraph, HTuple hv_Border);

// Procedures 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off()
{

	//This procedure sets different update settings to 'off'.
	//This is useful to get the best performance and reduce overhead.
	//
	// dev_update_pc(...); only in hdevelop
	// dev_update_var(...); only in hdevelop
	// dev_update_window(...); only in hdevelop
	return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
	HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_GenParamName, hv_GenParamValue;

	//This procedure displays text in a graphics window.
	//
	//Input parameters:
	//WindowHandle: The WindowHandle of the graphics window, where
	//   the message should be displayed
	//String: A tuple of strings containing the text message to be displayed
	//CoordSystem: If set to 'window', the text position is given
	//   with respect to the window coordinate system.
	//   If set to 'image', image coordinates are used.
	//   (This may be useful in zoomed images.)
	//Row: The row coordinate of the desired text position
	//   A tuple of values is allowed to display text at different
	//   positions.
	//Column: The column coordinate of the desired text position
	//   A tuple of values is allowed to display text at different
	//   positions.
	//Color: defines the color of the text as string.
	//   If set to [], '' or 'auto' the currently set color is used.
	//   If a tuple of strings is passed, the colors are used cyclically...
	//   - if |Row| == |Column| == 1: for each new textline
	//   = else for each text position.
	//Box: If Box[0] is set to 'true', the text is written within an orange box.
	//     If set to' false', no box is displayed.
	//     If set to a color string (e.g. 'white', '#FF00CC', etc.),
	//       the text is written in a box of that color.
	//     An optional second value for Box (Box[1]) controls if a shadow is displayed:
	//       'true' -> display a shadow in a default color
	//       'false' -> display no shadow
	//       otherwise -> use given string as color string for the shadow color
	//
	//It is possible to display multiple text strings in a single call.
	//In this case, some restrictions apply:
	//- Multiple text positions can be defined by specifying a tuple
	//  with multiple Row and/or Column coordinates, i.e.:
	//  - |Row| == n, |Column| == n
	//  - |Row| == n, |Column| == 1
	//  - |Row| == 1, |Column| == n
	//- If |Row| == |Column| == 1,
	//  each element of String is display in a new textline.
	//- If multiple positions or specified, the number of Strings
	//  must match the number of positions, i.e.:
	//  - Either |String| == n (each string is displayed at the
	//                          corresponding position),
	//  - or     |String| == 1 (The string is displayed n times).
	//
	//
	//Convert the parameters for disp_text.
	if (0 != (HTuple(hv_Row == HTuple()).TupleOr(hv_Column == HTuple())))
	{
		return;
	}
	if (0 != (hv_Row == -1))
	{
		hv_Row = 12;
	}
	if (0 != (hv_Column == -1))
	{
		hv_Column = 12;
	}
	//
	//Convert the parameter Box to generic parameters.
	hv_GenParamName = HTuple();
	hv_GenParamValue = HTuple();
	if (0 != ((hv_Box.TupleLength()) > 0))
	{
		if (0 != (HTuple(hv_Box[0]) == HTuple("false")))
		{
			//Display no box
			hv_GenParamName = hv_GenParamName.TupleConcat("box");
			hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
		}
		else if (0 != (HTuple(hv_Box[0]) != HTuple("true")))
		{
			//Set a color other than the default.
			hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
			hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[0]));
		}
	}
	if (0 != ((hv_Box.TupleLength()) > 1))
	{
		if (0 != (HTuple(hv_Box[1]) == HTuple("false")))
		{
			//Display no shadow.
			hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
			hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
		}
		else if (0 != (HTuple(hv_Box[1]) != HTuple("true")))
		{
			//Set a shadow color other than the default.
			hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
			hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[1]));
		}
	}
	//Restore default CoordSystem behavior.
	if (0 != (hv_CoordSystem != HTuple("window")))
	{
		hv_CoordSystem = "image";
	}
	//
	if (0 != (hv_Color == HTuple("")))
	{
		//disp_text does not accept an empty string for Color.
		hv_Color = HTuple();
	}
	//
	DispText(hv_WindowHandle, hv_String, hv_CoordSystem, hv_Row, hv_Column, hv_Color,
		hv_GenParamName, hv_GenParamValue);
	return;
}

// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld(HObject* ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
	HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
{

	// Local iconic variables
	HObject  ho_TempArrow;

	// Local control variables
	HTuple  hv_Length, hv_ZeroLengthIndices, hv_DR;
	HTuple  hv_DC, hv_HalfHeadWidth, hv_RowP1, hv_ColP1, hv_RowP2;
	HTuple  hv_ColP2, hv_Index;

	//This procedure generates arrow shaped XLD contours,
	//pointing from (Row1, Column1) to (Row2, Column2).
	//If starting and end point are identical, a contour consisting
	//of a single point is returned.
	//
	//input parameteres:
	//Row1, Column1: Coordinates of the arrows' starting points
	//Row2, Column2: Coordinates of the arrows' end points
	//HeadLength, HeadWidth: Size of the arrow heads in pixels
	//
	//output parameter:
	//Arrow: The resulting XLD contour
	//
	//The input tuples Row1, Column1, Row2, and Column2 have to be of
	//the same length.
	//HeadLength and HeadWidth either have to be of the same length as
	//Row1, Column1, Row2, and Column2 or have to be a single element.
	//If one of the above restrictions is violated, an error will occur.
	//
	//
	//Init
	GenEmptyObj(&(*ho_Arrow));
	//
	//Calculate the arrow length
	DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, &hv_Length);
	//
	//Mark arrows with identical start and end point
	//(set Length to -1 to avoid division-by-zero exception)
	hv_ZeroLengthIndices = hv_Length.TupleFind(0);
	if (0 != (hv_ZeroLengthIndices != -1))
	{
		hv_Length[hv_ZeroLengthIndices] = -1;
	}
	//
	//Calculate auxiliary variables.
	hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
	hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
	hv_HalfHeadWidth = hv_HeadWidth / 2.0;
	//
	//Calculate end points of the arrow head.
	hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
	hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
	hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
	hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
	//
	//Finally create output XLD contour for each input point pair
	{
		HTuple end_val45 = (hv_Length.TupleLength()) - 1;
		HTuple step_val45 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val45, step_val45); hv_Index += step_val45)
		{
			if (0 != (HTuple(hv_Length[hv_Index]) == -1))
			{
				//Create_ single points for arrows with identical start and end point
				GenContourPolygonXld(&ho_TempArrow, HTuple(hv_Row1[hv_Index]), HTuple(hv_Column1[hv_Index]));
			}
			else
			{
				//Create arrow contour
				GenContourPolygonXld(&ho_TempArrow, ((((HTuple(hv_Row1[hv_Index]).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP1[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP2[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index])),
					((((HTuple(hv_Column1[hv_Index]).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP1[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP2[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index])));
			}
			ConcatObj((*ho_Arrow), ho_TempArrow, &(*ho_Arrow));
		}
	}
	return;
}

// Local procedures 
void plot_histo(HTuple hv_Histogram, HTuple hv_WindowHandle, HTuple hv_LabelX, HTuple hv_ValueXMin,
	HTuple hv_ValueXMax, HTuple hv_ColorAxis, HTuple hv_ColorGraph, HTuple hv_Border)
{

	// Local iconic variables
	HObject  ho_Histo, ho_ArrowX, ho_ArrowY;

	// Local control variables
	HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2;
	HTuple  hv_PlotAreaX, hv_PlotAreaY, hv_OriginX, hv_OriginY;
	HTuple  hv_MinY, hv_MaxY, hv_ScaleX, hv_ScaleY, hv_polyX;
	HTuple  hv_polyY, hv_Value, hv_Ascent, hv_Descent, hv_W;
	HTuple  hv_H, hv_MinXD, hv_Ascent1, hv_Descent1, hv_MaxXD;
	HTuple  hv_Ascent2, hv_Descent2, hv_Ascent3, hv_Descent3;
	HTuple  hv_Ascent4, hv_Descent4;

	//This procedure plots the Histogram within the value range
	//[LabelXMin,LabelXMax] into the WindowHandle by leaving a
	//relative Border around the plot.
	//
	if (0 != (HTuple(HTuple((hv_Histogram.TupleLength()) <= 0).TupleOr(hv_Border < 0)).TupleOr(hv_Border >= 1)))
	{
		disp_message(hv_WindowHandle, "Failed to plot histogram", "window", 12, 12, "black",
			"true");
		return;
	}
	//
	//Determine the area to be used for the plot.
	GetPart(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
	hv_PlotAreaX = ((hv_Column2 - hv_Column1) + 1) * (1 - (hv_Border * 2));
	hv_PlotAreaY = ((hv_Row2 - hv_Row1) + 1) * (1 - (hv_Border * 2));
	hv_OriginX = hv_Column1 + (hv_Border * ((hv_Column2 - hv_Column1) + 1));
	hv_OriginY = hv_Row2 - (hv_Border * ((hv_Row2 - hv_Column1) + 1));
	//
	//Determine the extent of the function to be plotted
	hv_MinY = (hv_Histogram.TupleConcat(0)).TupleMin();
	hv_MaxY = hv_Histogram.TupleMax();
	//
	//Determine the scaling values
	hv_ScaleX = hv_PlotAreaX / (hv_Histogram.TupleLength());
	if (0 != (hv_MaxY == hv_MinY))
	{
		hv_ScaleY = hv_PlotAreaY;
		hv_MaxY = "";
	}
	else
	{
		hv_ScaleY = hv_PlotAreaY / (hv_MaxY - hv_MinY);
	}
	//
	//Display the histogram values
	hv_polyX = HTuple();
	hv_polyY = HTuple();
	{
		HTuple end_val32 = (hv_Histogram.TupleLength()) - 1;
		HTuple step_val32 = 1;
		for (hv_Value = 0; hv_Value.Continue(end_val32, step_val32); hv_Value += step_val32)
		{
			hv_polyX = hv_polyX.TupleConcat(hv_OriginX + (hv_Value * hv_ScaleX));
			hv_polyY = hv_polyY.TupleConcat(hv_OriginY - ((HTuple(hv_Histogram[hv_Value]) - hv_MinY) * hv_ScaleY));
			hv_polyX = hv_polyX.TupleConcat(hv_OriginX + ((hv_Value + 1) * hv_ScaleX));
			hv_polyY = hv_polyY.TupleConcat(hv_OriginY - ((HTuple(hv_Histogram[hv_Value]) - hv_MinY) * hv_ScaleY));
		}
	}
	hv_polyX = (hv_polyX.TupleConcat(hv_OriginX + ((hv_Histogram.TupleLength()) * hv_ScaleX))).TupleConcat(hv_OriginX);
	hv_polyY = (hv_polyY.TupleConcat(hv_OriginY)).TupleConcat(hv_OriginY);
	HDevWindowStack::SetActive(hv_WindowHandle);
	if (HDevWindowStack::IsOpen())
		SetLineWidth(HDevWindowStack::GetActive(), 1);
	if (HDevWindowStack::IsOpen())
		SetColor(HDevWindowStack::GetActive(), hv_ColorGraph);
	GenRegionPolygonFilled(&ho_Histo, hv_polyY, hv_polyX);
	if (HDevWindowStack::IsOpen())
		DispObj(ho_Histo, HDevWindowStack::GetActive());
	//
	//Display the coordinate system
	if (HDevWindowStack::IsOpen())
		SetLineWidth(HDevWindowStack::GetActive(), 1);
	if (HDevWindowStack::IsOpen())
		SetColor(HDevWindowStack::GetActive(), hv_ColorAxis);
	gen_arrow_contour_xld(&ho_ArrowX, hv_OriginY, hv_OriginX, hv_OriginY, hv_OriginX + hv_PlotAreaX,
		5, 5);
	gen_arrow_contour_xld(&ho_ArrowY, hv_OriginY, hv_OriginX, hv_OriginY - hv_PlotAreaY,
		hv_OriginX, 5, 5);
	if (HDevWindowStack::IsOpen())
		DispObj(ho_ArrowX, HDevWindowStack::GetActive());
	if (HDevWindowStack::IsOpen())
		DispObj(ho_ArrowY, HDevWindowStack::GetActive());
	//
	if (HDevWindowStack::IsOpen())
		SetColor(HDevWindowStack::GetActive(), hv_ColorAxis);
	GetStringExtents(hv_WindowHandle, hv_LabelX, &hv_Ascent, &hv_Descent, &hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY + 10, (hv_OriginX + (hv_PlotAreaX / 2)) - (hv_W / 2));
	WriteString(hv_WindowHandle, hv_LabelX);
	//
	if (0 != ((hv_ValueXMin.TupleInt()) == hv_ValueXMin))
	{
		hv_MinXD = hv_ValueXMin.TupleInt();
	}
	else
	{
		hv_MinXD = hv_ValueXMin;
	}
	GetStringExtents(hv_WindowHandle, hv_MinXD.TupleString("3.1f"), &hv_Ascent1, &hv_Descent1,
		&hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY + 10, hv_OriginX);
	WriteString(hv_WindowHandle, hv_MinXD.TupleString("3.1f"));
	if (0 != ((hv_ValueXMax.TupleInt()) == hv_ValueXMax))
	{
		hv_MaxXD = hv_ValueXMax.TupleInt();
	}
	else
	{
		hv_MaxXD = hv_ValueXMax;
	}
	GetStringExtents(hv_WindowHandle, hv_MaxXD.TupleString("3.1f"), &hv_Ascent2, &hv_Descent2,
		&hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY + 10, (hv_OriginX + hv_PlotAreaX) - hv_W);
	WriteString(hv_WindowHandle, hv_MaxXD.TupleString("3.1f"));
	GetStringExtents(hv_WindowHandle, hv_MinY, &hv_Ascent3, &hv_Descent3, &hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY - hv_H, (hv_OriginX - 10) - hv_W);
	WriteString(hv_WindowHandle, hv_MinY);
	GetStringExtents(hv_WindowHandle, hv_MaxY, &hv_Ascent4, &hv_Descent4, &hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY - hv_PlotAreaY, (hv_OriginX - 10) - hv_W);
	WriteString(hv_WindowHandle, hv_MaxY);
	//
	return;
}
// 获取指定路径下的所有文件路径和文件名
void getFiles(string path, vector<string>& filepaths, vector<string>& filenames)//&表引用,相当于给现有变量起个别名
{
	/*files存储文件的路径及名称(eg.C:\Users\WUQP\Desktop\test_devided\data1.txt)
	ownname只存储文件的名称(eg.data1.txt)*/
	long hFile = 0;//文件句柄;
	struct _finddata_t fileinfo;//文件信息; Struct _finddata_t是用来存储文件各种信息的结构体
	/*struct _finddata_t
		{
			 unsigned attrib;           //文件属性的存储位置
			 time_t time_create;        //保存从1970年1月1日0时0分0秒到现在时刻的秒数
			 time_t time_access;        //文件最后一次被访问的时间
			 time_t time_write;         //文件最后一次被修改的时间
			 _fsize_t size;             //文件的大小（字节数表示）
			 char name[_MAX_FNAME];     //文件的文件名
		};*/
	string p;

	hFile = _findfirst(p.assign(path).append("\\*.jpg").c_str(), &fileinfo);//查找文件，如果查找成功的话，将返回一个long型的唯一的查找用的句柄（就是一个唯一编号）；若失败，则返回-1
	if (hFile != -1)
	{
		do
		{
			filenames.push_back(fileinfo.name);
			filepaths.push_back(path + "/" + fileinfo.name);
		} while (_findnext(hFile, &fileinfo) == 0);//_findnext若成功返回0，否则返回-1
	}
	_findclose(hFile);//关闭句柄 
}
//获取当前工作路径
void getCurrentPath(string& path)
{
	char* buffer;
	if ((buffer = _getcwd(NULL, 0)) == NULL)
		perror("_getcwd error");
	else
	{
		path = buffer;
		free(buffer);
	}
}

// 滤波并保存
// save_path表示保存路径，image表示要处理的图片
// row和column表示滤波器大小，默认50*50
HObject meanImage(string save_path, HObject image, int row=50, int column=50)
{
	HObject ho_ImageMean;  // 滤波后的图片
	save_path = save_path + "_meanImage.png";
	HTuple h_save_path(save_path.c_str());  // 数据类型转换

	MeanImage(image, &ho_ImageMean, row, column);
	
	WriteImage(ho_ImageMean, "png", 0, h_save_path.S());
	return ho_ImageMean;
}
// 直接阈值化并保存

// string save_path,表示保存的路径； HObject image表示要阈值化的图片,未经过滤波的原图
void binaryMeanImage(string save_path, HObject image)
{
	save_path = save_path + "_BinaryMeanImage.png";
	HTuple h_save_path(save_path.c_str());  // 数据类型转换
	HTuple hv_UsedThreshold;
	HObject  ho_Image1;
	HTuple  hv_Area, hv_Row, hv_Column, hv_Area1, hv_rate, hv_Width, hv_Height;
	HObject  ho_Region1;
	BinaryThreshold(image, &ho_Region1, "max_separability", "dark", &hv_UsedThreshold);  // 二值化输入图片
	// 计算面积比率
	AreaCenter(image, &hv_Area, &hv_Row, &hv_Column);
	AreaCenter(ho_Region1, &hv_Area1, &hv_Row, &hv_Column);
	hv_rate = (hv_Area1 * 100) / hv_Area;
	h_save_path = h_save_path.S() + hv_rate + "%.png";
	GetImageSize(image, &hv_Width, &hv_Height);
	RegionToBin(ho_Region1, &ho_Image1, 255, 0, hv_Width, hv_Height);
	WriteImage(ho_Image1, "png", 0, h_save_path.S());
	
}
// 滤波后直接阈值化之后进行形态学分析并保存
// string save_path,表示存储路径； HObject image, 表示要阈值化的图片；int radius=25 表示圆形闭运算的半径
void blobBinaryMeanImage(string save_path, HObject image, int radius=25)
{
	save_path = save_path + "_BinaryMeanImage_WithBlob.png";

	HTuple h_save_path(save_path.c_str());  // 数据类型转换
	HObject  ho_RegionClosing, ho_RegionFillUp,region, ho_Region1, ho_Image1;
	HTuple  hv_UsedThreshold, hv_Area, hv_Row, hv_Column, hv_Area1, hv_rate;
	BinaryThreshold(image, &ho_Region1, "max_separability", "dark", &hv_UsedThreshold);  // 二值化输入图片
	ClosingCircle(ho_Region1, &ho_RegionClosing, radius);
	FillUp(ho_RegionClosing, &ho_RegionFillUp);
	//特征计算
	AreaCenter(image, &hv_Area, &hv_Row, &hv_Column);  // 整张图片大小
	AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row, &hv_Column);  //Blob分析之后识别区域大小
	hv_rate = (hv_Area1 * 100) / hv_Area;
	h_save_path = h_save_path.S() + hv_rate + "%.png";
	GetImageSize(image, &hv_Row, &hv_Column);
	RegionToBin(ho_Region1, &ho_Image1, 255, 0, hv_Row, hv_Column);
	WriteImage(ho_Image1, "png", 0, h_save_path.S());
}
// 计算灰度直方图并保存
// 需要传入窗口值
void histo(string save_path, HObject image, HTuple hv_WindowHandle)
{
	save_path = save_path + "_gray_histogram.png";
	HTuple h_save_path(save_path.c_str());  // 数据类型转换
	HTuple hv_HistoBorder, hv_Min, hv_Max, hv_Range, hv_Histo, hv_BinSize;
	HObject ho_Image1;
	hv_HistoBorder = 0.1;
	MinMaxGray(image, image, 0, &hv_Min, &hv_Max, &hv_Range);
	GrayHistoRange(image, image, hv_Min, hv_Max, ((hv_Max - hv_Min) + 1).TupleInt(), &hv_Histo, &hv_BinSize);
	plot_histo(hv_Histo, hv_WindowHandle, "Gray values", hv_Min, hv_Max, "white", "red",hv_HistoBorder);
	DumpWindowImage(&ho_Image1, hv_WindowHandle);
	WriteImage(ho_Image1, "png", 0, h_save_path.S());
}
// 颜色空间转换
// 参数地址 返回三个分量并保存到指定路径
void rgbToHsv(string save_path, HObject ho_Image, HObject &ho_Hue, HObject &ho_Saturation, HObject &ho_Intensity)
{

	HObject ho_Red, ho_Green, ho_Blue;
	HTuple h_save_path;  // 数据类型转换

	Decompose3(ho_Image, &ho_Red, &ho_Green, &ho_Blue);
	TransFromRgb(ho_Red, ho_Green, ho_Blue, &ho_Hue, &ho_Saturation, &ho_Intensity,	"hsv");
	// ho_Hue分量
	save_path = save_path + "_Hue.png";  // 最终输出

	h_save_path = save_path.c_str();  // 保存图片的路径

	WriteImage(ho_Hue, "png", 0, h_save_path.S());
	//ho_Saturation
	save_path = save_path + "_Saturation.png";  // 最终输出

	h_save_path = save_path.c_str();  // 保存图片的路径

	WriteImage(ho_Saturation, "png", 0, h_save_path.S());
	// ho_Intensity
	save_path = save_path + "_Intensity.png";  // 最终输出

	h_save_path = save_path.c_str();  // 保存图片的路径

	WriteImage(ho_Intensity, "png", 0, h_save_path.S());

}
/*************************函数说明*******************
* 函数名称:binaryHue()
* 函数功能：对颜色空间转换后的Hue分量做阈值化分析
* 函数参数：
	string save_path：表示保存路径 
	HObject ho_Hue： 表示传入的Hue分量
	HTuple hv_Area,：表示原图像的面积
	HTuple hv_Width：表示原图像的宽（width）
	HTuple hv_Height：表示原图像的高（height）

*/
void binaryHue(string save_path, HObject ho_Hue, HTuple hv_Area, HTuple hv_Width, HTuple hv_Height)
{
	HTuple h_save_path, hv_UsedThreshold, hv_Area1, hv_Row1, hv_Column1, hv_rate;  // 数据类型转换
	HObject ho_Region, ho_RegionClosing, ho_RegionFillUp, ho_Image;

	// 阈值化
	BinaryThreshold(ho_Hue, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);
	
	//BLOB分析
	ClosingCircle(ho_Region, &ho_RegionClosing, 25);
	FillUp(ho_RegionClosing, &ho_RegionFillUp);

	//特征计算
	AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
	hv_rate = (hv_Area1 * 100) / hv_Area;

	save_path = save_path + "_binaryThreshold_Hue_Blob_";
	h_save_path = save_path.c_str();
	RegionToBin(ho_Region, &ho_Image, 255, 0, hv_Width, hv_Height);
	WriteImage(ho_Image, "png", 0, h_save_path.S());
}

/*************************函数说明*******************
* 函数名称:binarySaturation()
* 函数功能：对颜色空间转换后的Saturation分量做阈值化分析
* 函数参数：
	string save_path：表示保存路径
	HObject ho_Hue： 表示传入的Hue分量
	HTuple hv_Area,：表示原图像的面积
	HTuple hv_Width：表示原图像的宽（width）
	HTuple hv_Height：表示原图像的高（height）

*/
void binarySaturation(string save_path, HObject ho_Saturation, HTuple hv_Area, HTuple hv_Width, HTuple hv_Height)
{
	HTuple h_save_path, hv_UsedThreshold, hv_Area1, hv_Row1, hv_Column1, hv_rate;  // 数据类型转换
	HObject ho_Region, ho_RegionClosing, ho_RegionFillUp, ho_Image;

	// 阈值化
	BinaryThreshold(ho_Saturation, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);

	//BLOB分析
	ClosingCircle(ho_Region, &ho_RegionClosing, 25);
	FillUp(ho_RegionClosing, &ho_RegionFillUp);

	//特征计算
	AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
	hv_rate = (hv_Area1 * 100) / hv_Area;

	save_path = save_path + "_binaryThreshold_Saturation_Blob_";
	h_save_path = save_path.c_str();
	RegionToBin(ho_Region, &ho_Image, 255, 0, hv_Width, hv_Height);
	WriteImage(ho_Image, "png", 0, h_save_path.S());
}

/*************************函数说明*******************
* 函数名称:binaryIntensity()
* 函数功能：对颜色空间转换后的Intensity分量做阈值化分析
* 函数参数：
	string save_path：表示保存路径
	HObject ho_Hue： 表示传入的Hue分量
	HTuple hv_Area,：表示原图像的面积
	HTuple hv_Width：表示原图像的宽（width）
	HTuple hv_Height：表示原图像的高（height）

*/
void binaryIntensity(string save_path, HObject ho_Intensity, HTuple hv_Area, HTuple hv_Width, HTuple hv_Height)
{
	HTuple h_save_path, hv_UsedThreshold, hv_Area1, hv_Row1, hv_Column1, hv_rate;  // 数据类型转换
	HObject ho_Region, ho_RegionClosing, ho_RegionFillUp, ho_Image;

	// 阈值化
	BinaryThreshold(ho_Intensity, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);

	//BLOB分析
	ClosingCircle(ho_Region, &ho_RegionClosing, 25);
	FillUp(ho_RegionClosing, &ho_RegionFillUp);

	//特征计算
	AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
	hv_rate = (hv_Area1 * 100) / hv_Area;

	save_path = save_path + "_binaryThreshold_Intensity_Blob_";
	h_save_path = save_path.c_str();
	RegionToBin(ho_Region, &ho_Image, 255, 0, hv_Width, hv_Height);
	WriteImage(ho_Image, "png", 0, h_save_path.S());
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
extern "C" _declspec(dllexport) void action()
{

	// Local iconic variables
	HObject  ho_Image, ho_Image11, ho_Image2, ho_Image3, ho_ImageZoom;
	HObject  ho_Image1, ho_ImageMean, ho_Red, ho_Green, ho_Blue;
	HObject  ho_Region1, ho_RegionClosing1, ho_RegionFillUp1;
	HObject  ho_Hue, ho_Saturation, ho_Intensity, ho_Region;
	HObject  ho_RegionClosing, ho_RegionFillUp, ho_Region2, ho_Region3;

	// Local control variables
	HTuple  hv_Width, hv_Height, hv_WindowHandle;
	HTuple  hv_picture_path, hv_picture_index, hv_UsedThreshold1;
	HTuple  hv_Area, hv_Row1, hv_Column1, hv_Area1, hv_rate;
	HTuple  hv_HistoBorder, hv_Min, hv_Max, hv_Range, hv_Histo;
	HTuple  hv_BinSize, hv_UsedThreshold, hv_UsedThreshold2;
	HTuple  hv_UsedThreshold3;

	//一次处理一张图片
	//每次处理后存储图片
	//dev_update_off();
	//if (HDevWindowStack::IsOpen())
	//	CloseWindow(HDevWindowStack::Pop());
	// 函数参数
	string work_path = "";  // 当前工作路径
	vector<string> file_path;  // 当前工作路径下的所有文件的完整路径，含后缀
	vector<string> filenames;  // 当前工作路径下的所有文件名，仅名字
	// 读取和保存文件路径
	string c_read_path;  // 最终读取文件的路径,C++格式,含文件名
	string c_save_path;  // 存储保存文件的路径，含文件名
	string temp;  // 存储包含不同后缀名的文件保存路径




	getCurrentPath(work_path);  // 获取当前路径
	c_save_path = work_path + "\\temp\\processed_img\\";
	string savePath = c_save_path;  // 在for循环后面还原保存路径
	work_path = work_path + "\\temp\\raw_img\\";

	getFiles(work_path, file_path, filenames);  // 获取当前路路径下的所有文件路径和文件名
	if (!file_path.size() || !filenames.size())
	{
		cout << "None Files" << endl;
		exit(-1);
	}
	// 得到的文件路径转换到halcon中
	// 将char*与string转换，建立连接 https://blog.csdn.net/cogbee/article/details/8931838
	// 路径转换
	// 第一次 读取和保存路径
	
	
	for (int i = 0; i < filenames.size(); i = i + 1)
	{
		c_read_path = work_path + filenames[i];

		string name = filenames[i].substr(0, 5);
		c_save_path = savePath + name;  // 文件，不带后缀名
		temp = c_save_path + ".png";  // 原名
			   		
		HTuple saveHTuple;  // 保存图片的路径信息
		saveHTuple[0] = c_read_path.c_str();  // 读取图片的路径
		saveHTuple[1] = temp.c_str();  // 保存图片的路径

		//if (HDevWindowStack::IsOpen())
			//CloseWindow(HDevWindowStack::Pop());

		//  读取图片
		ReadImage(&ho_Image, saveHTuple[0].S());
		GetImageSize(ho_Image, &hv_Width, &hv_Height);
		//ZoomImageSize(ho_Image, &ho_ImageZoom, 1536, 1024, "constant");
		SetWindowAttr("background_color", "black");
		OpenWindow(0, 0, hv_Width, hv_Height, 0, "visible", "", &hv_WindowHandle);
		HDevWindowStack::Push(hv_WindowHandle);
		SetPart(hv_WindowHandle, 0, 0, hv_Height, hv_Width);
		Decompose3(ho_Image, &ho_Image11, &ho_Image2, &ho_Image3);

		//窗口大小、显示等预设值

		
		// 设置存储路径
		
		WriteImage(ho_Image1, "png", 0, saveHTuple[1].S());
		//加入均值滤波
		temp = c_save_path + "_meanImage.png";  // 最终输出
		meanImage(temp, ho_Image);
		MeanImage(ho_Image, &ho_ImageMean, 50, 50);
		if (HDevWindowStack::IsOpen())
			DispObj(ho_ImageMean, HDevWindowStack::GetActive());
		Decompose3(ho_ImageMean, &ho_Red, &ho_Green, &ho_Blue);
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		if (HDevWindowStack::IsOpen())
			DispObj(ho_ImageMean, HDevWindowStack::GetActive());
		DumpWindowImage(&ho_Image1, hv_WindowHandle);
		// 保存均值滤波的图片
		
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径
		 
		WriteImage(ho_Image1, "png", 0, saveHTuple[1].S());
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		Rgb1ToGray(ho_ImageMean, &ho_Image);
		//均值滤波之后直接阈值化效果
		if (HDevWindowStack::IsOpen())
			SetColored(HDevWindowStack::GetActive(), 12);
		BinaryThreshold(ho_Image, &ho_Region1, "max_separability", "dark", &hv_UsedThreshold1);
		//整体面积计算
		AreaCenter(ho_Image, &hv_Area, &hv_Row1, &hv_Column1);
		//快速阈值化之后面积占比计算
		AreaCenter(ho_Region1, &hv_Area1, &hv_Row1, &hv_Column1);
		hv_rate = (hv_Area1 * 100) / hv_Area;
		//下载图片
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		if (HDevWindowStack::IsOpen())
			DispObj(ho_Region1, HDevWindowStack::GetActive());
		DumpWindowImage(&ho_Image1, hv_WindowHandle);

		temp = c_save_path + "_binaryThresholdMeanImage_";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径

		saveHTuple[1] = (saveHTuple[1].S() + hv_rate) + "%.png";
		 
		WriteImage(ho_Image1, "png", 0, saveHTuple[1].S());
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		//进行Blob分析
		ClosingCircle(ho_Region1, &ho_RegionClosing1, 25);
		FillUp(ho_RegionClosing1, &ho_RegionFillUp1);

		//特征计算
		AreaCenter(ho_RegionFillUp1, &hv_Area1, &hv_Row1, &hv_Column1);
		hv_rate = (hv_Area1 * 100) / hv_Area;
		//下载图片
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		if (HDevWindowStack::IsOpen())
			DispObj(ho_RegionFillUp1, HDevWindowStack::GetActive());
		DumpWindowImage(&ho_Image1, hv_WindowHandle);

		temp = c_save_path + "_binaryThresholdMeanImage_WithBlob_";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径

		hv_picture_index = (saveHTuple[1].S() + hv_rate) + "%.png";
		WriteImage(ho_Image1, "png", 0, hv_picture_index);

		//计算图像的灰度值分布
		hv_HistoBorder = 0.1;
		MinMaxGray(ho_Image, ho_Image, 0, &hv_Min, &hv_Max, &hv_Range);
		GrayHistoRange(ho_Image, ho_Image, hv_Min, hv_Max, ((hv_Max - hv_Min) + 1).TupleInt(),
			&hv_Histo, &hv_BinSize);
		//显示灰度直方图
		HDevWindowStack::SetActive(hv_WindowHandle);
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		if (HDevWindowStack::IsOpen())
			SetDraw(HDevWindowStack::GetActive(), "fill");
		plot_histo(hv_Histo, hv_WindowHandle, "Gray values", hv_Min, hv_Max, "white", "red",
			hv_HistoBorder);
		//下载图片
		DumpWindowImage(&ho_Image1, hv_WindowHandle);

		temp = c_save_path + "_gray_histogram.png";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径

		WriteImage(ho_Image1, "png", 0, saveHTuple[1].S());

		//颜色空间转换
		TransFromRgb(ho_Red, ho_Green, ho_Blue, &ho_Hue, &ho_Saturation, &ho_Intensity,
			"hsv");
		//对HSV三个分量分析
		//有钢筋的选择Hue分量做阈值化的效果最好
		//有掌子面的选择Saturation效果更好
		if (HDevWindowStack::IsOpen())
			SetColored(HDevWindowStack::GetActive(), 12);
		//Hue 分量分析
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		BinaryThreshold(ho_Hue, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);

		//BLOB分析
		ClosingCircle(ho_Region, &ho_RegionClosing, 25);
		FillUp(ho_RegionClosing, &ho_RegionFillUp);

		//特征计算
		AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
		hv_rate = (hv_Area1 * 100) / hv_Area;
		//下载图片
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		if (HDevWindowStack::IsOpen())
			DispObj(ho_RegionFillUp, HDevWindowStack::GetActive());
		DumpWindowImage(&ho_Image1, hv_WindowHandle);

		temp = c_save_path + "_binaryThreshold_Hue_Blob_";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径

		hv_picture_index = (saveHTuple[1].S() + hv_rate) + "%.png";
		WriteImage(ho_Image1, "png", 0, hv_picture_index);

		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		//Intensity 分量分析
		if (HDevWindowStack::IsOpen())
			SetColored(HDevWindowStack::GetActive(), 12);
		BinaryThreshold(ho_Intensity, &ho_Region2, "max_separability", "dark", &hv_UsedThreshold2);


		//BLOB分析
		ClosingCircle(ho_Region2, &ho_RegionClosing, 25);
		FillUp(ho_RegionClosing, &ho_RegionFillUp);

		//特征计算
		AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
		hv_rate = (hv_Area1 * 100) / hv_Area;
		//下载图片
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		if (HDevWindowStack::IsOpen())
			DispObj(ho_RegionFillUp, HDevWindowStack::GetActive());
		DumpWindowImage(&ho_Image1, hv_WindowHandle);

		temp = c_save_path + "_binaryThreshold_Intensity_Blob_";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径

		hv_picture_index = (saveHTuple[1].S() + hv_rate) + "%.png";
		WriteImage(ho_Image1, "png", 0, hv_picture_index);

		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		//Saturation 分量分析
		if (HDevWindowStack::IsOpen())
			SetColored(HDevWindowStack::GetActive(), 12);
		BinaryThreshold(ho_Saturation, &ho_Region3, "max_separability", "light", &hv_UsedThreshold3);
		//BLOB分析
		ClosingCircle(ho_Region3, &ho_RegionClosing, 25);
		FillUp(ho_RegionClosing, &ho_RegionFillUp);
		//特征计算
		AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
		hv_rate = (hv_Area1 * 100) / hv_Area;
		//下载图片
		if (HDevWindowStack::IsOpen())
			ClearWindow(HDevWindowStack::GetActive());
		if (HDevWindowStack::IsOpen())
			DispObj(ho_RegionFillUp, HDevWindowStack::GetActive());
		DumpWindowImage(&ho_Image1, hv_WindowHandle);

		temp = c_save_path + "_binaryThreshold_Saturation_Blob_";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径

		hv_picture_index = (saveHTuple[1].S() + hv_rate) + "%.png";
		WriteImage(ho_Image1, "png", 0, hv_picture_index);

		// 保存颜色空间变换的图片信息
		// ho_Hue分量
		temp = c_save_path + "_Hue.png";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径
		 
		WriteImage(ho_Hue, "png", 0, saveHTuple[1].S());
		//ho_Saturation
		temp = c_save_path + "_Saturation.png";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径
		 
		WriteImage(ho_Saturation, "png", 0, saveHTuple[1].S());
		// ho_Intensity
		temp = c_save_path + "_Intensity.png";  // 最终输出
		
		saveHTuple[1] = temp.c_str();  // 保存图片的路径
		 
		WriteImage(ho_Intensity, "png", 0, saveHTuple[1].S());

		// 参数还原
		c_save_path = savePath;
		cout << "i=" << i << endl;

	}


}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void* info)
{
	UnlockMutex(gStartMutex);
}

static Herror apple_action(void** parameters)
{
	// Wait until the timer has fired to start processing.
	LockMutex(gStartMutex);
	UnlockMutex(gStartMutex);

	try
	{
		action();
	}
	catch (HException & exception)
	{
		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
			(const char*)exception.ProcName(),
			(const char*)exception.ErrorMessage());
	}

	// Tell the main thread to terminate itself.
	LockMutex(gStartMutex);
	gTerminate = TRUE;
	UnlockMutex(gStartMutex);
	CFRunLoopStop(CFRunLoopGetMain());
	return H_MSG_OK;
}

static int apple_main(int argc, char* argv[])
{
	Herror                error;
	CFRunLoopTimerRef     Timer;
	CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

	CreateMutex("type", "sleep", &gStartMutex);
	LockMutex(gStartMutex);

	error = HpThreadHandleAlloc(&gActionThread);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadHandleAlloc failed: %d\n", error);
		exit(1);
	}

	error = HpThreadCreate(gActionThread, 0, apple_action);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadCreate failed: %d\n", error);
		exit(1);
	}

	Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
		CFAbsoluteTimeGetCurrent(), 0, 0, 0,
		timer_callback, &TimerContext);
	if (!Timer)
	{
		fprintf(stderr, "CFRunLoopTimerCreate failed\n");
		exit(1);
	}
	CFRunLoopAddTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);

	for (;;)
	{
		HBOOL terminate;

		CFRunLoopRun();

		LockMutex(gStartMutex);
		terminate = gTerminate;
		UnlockMutex(gStartMutex);

		if (terminate)
			break;
	}

	CFRunLoopRemoveTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);
	CFRelease(Timer);

	error = HpThreadHandleFree(gActionThread);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadHandleFree failed: %d\n", error);
		exit(1);
	}

	ClearMutex(gStartMutex);
	return 0;
}
#endif

extern "C" _declspec(dllexport) int main_action(int argc, char* argv[])
{
	int ret = 0;

	try
	{
#if defined(_WIN32)
		SetSystem("use_window_thread", "true");
#elif defined(__linux__) && !defined(__arm__)
		XInitThreads();
#endif

		// Default settings used in HDevelop (can be omitted) 
		SetSystem("width", 512);
		SetSystem("height", 512);

#ifndef __APPLE__
		action();
#else
		ret = apple_main(argc, argv);
#endif
	}
	catch (HException & exception)
	{
		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
			(const char*)exception.ProcName(),
			(const char*)exception.ErrorMessage());
		ret = 1;
	}
	return ret;
}

#endif


#endif


