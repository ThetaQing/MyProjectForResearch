///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 18.05
///////////////////////////////////////////////////////////////////////////////
/***********************文件说明*****************
* 实现功能：读取当前工作路径下的temp//raw_img文件夹下的所有图片，并实现滤波、颜色空间变换、三种分量的阈值化
*			以及面积比率计算。输入任何大小的图片（不宜过大，否则会内存溢出），输出图片为原图片尺寸。测试通过
*			通过输入参数控制调用哪个函数
* 后缀说明：filename.png 原图
			filename_binaryThreshold_Hue_Blob_38%：对Hue分量做阈值化并进行Blob分析
			filename_binaryThreshold_Intensity_Blob_54%：对Intensity分量做阈值化并进行Blob分析
			filename_binaryThreshold_Saturation_Blob_12%：对Saturation分量做阈值化并进行Blob分析
			filename_binaryThresholdMeanImage_54%：对滤波图像直接阈值化
			filename_binaryThresholdMeanImage_WithBlob_54%：对滤波图像直接阈值化后并进行Blob分析
			filename_gray_histogram：图像的灰度直方图
			filename_meanImage：滤波后的图
			filename_Hue:颜色空间变换后保存Hue分量
			filename_Intensity:保存Intensity分量
			filename_Saturation:保存Saturation分量
			最后的百分数表示识别区域占整张图像的比率
* 文件保存路径：当前工作路径下的//temp//processed_img文件下
* 函数说明：调用action(int)函数即可
* 函数参数说明：输入范围 [0,7]之间的整数
*			0：表示完成所有操作，滤波、滤波并阈值化、滤波阈值化之后做Blob分析、颜色空间转换、Hue/Saturation/Intensity分量的处理
*			1：表示仅实现滤波并阈值化
*			2：表示仅实现滤波阈值化并做Blob分析
*			3：表示颜色空间转换
*			4： 对Hue分量处理
*			5：对Saturation分量处理
*			6：对Intensity分量处理
*			7：绘制直方图




**/
// strcpy 报错
#pragma warning(disable : 4996)

#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif

#include <iostream>
#include <string>
#include <vector>
#include <io.h>
#include <direct.h>
#include <atlconv.h>



using namespace HalconCpp;
using namespace std;
// 后缀内存分配长度0
#define lengthOfPost 50



// Procedure declarations 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off();
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
	HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold,
	HTuple hv_Slant);
// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld(HObject* ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
	HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);
// Local procedures 
void plot_histo(HTuple hv_Histogram, HTuple hv_WindowHandle, HTuple hv_LabelX, HTuple hv_ValueXMin,
	HTuple hv_ValueXMax, HTuple hv_ColorAxis, HTuple hv_ColorGraph, HTuple hv_Border);

// Procedures 
// External procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off()
{

	//This procedure sets different update settings to 'off'.
	//This is useful to get the best performance and reduce overhead.
	//
	// dev_update_pc(...); only in hdevelop
	// dev_update_var(...); only in hdevelop
	// dev_update_window(...); only in hdevelop
	return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
	HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_GenParamName, hv_GenParamValue;

	//This procedure displays text in a graphics window.
	//
	//Input parameters:
	//WindowHandle: The WindowHandle of the graphics window, where
	//   the message should be displayed
	//String: A tuple of strings containing the text message to be displayed
	//CoordSystem: If set to 'window', the text position is given
	//   with respect to the window coordinate system.
	//   If set to 'image', image coordinates are used.
	//   (This may be useful in zoomed images.)
	//Row: The row coordinate of the desired text position
	//   A tuple of values is allowed to display text at different
	//   positions.
	//Column: The column coordinate of the desired text position
	//   A tuple of values is allowed to display text at different
	//   positions.
	//Color: defines the color of the text as string.
	//   If set to [], '' or 'auto' the currently set color is used.
	//   If a tuple of strings is passed, the colors are used cyclically...
	//   - if |Row| == |Column| == 1: for each new textline
	//   = else for each text position.
	//Box: If Box[0] is set to 'true', the text is written within an orange box.
	//     If set to' false', no box is displayed.
	//     If set to a color string (e.g. 'white', '#FF00CC', etc.),
	//       the text is written in a box of that color.
	//     An optional second value for Box (Box[1]) controls if a shadow is displayed:
	//       'true' -> display a shadow in a default color
	//       'false' -> display no shadow
	//       otherwise -> use given string as color string for the shadow color
	//
	//It is possible to display multiple text strings in a single call.
	//In this case, some restrictions apply:
	//- Multiple text positions can be defined by specifying a tuple
	//  with multiple Row and/or Column coordinates, i.e.:
	//  - |Row| == n, |Column| == n
	//  - |Row| == n, |Column| == 1
	//  - |Row| == 1, |Column| == n
	//- If |Row| == |Column| == 1,
	//  each element of String is display in a new textline.
	//- If multiple positions or specified, the number of Strings
	//  must match the number of positions, i.e.:
	//  - Either |String| == n (each string is displayed at the
	//                          corresponding position),
	//  - or     |String| == 1 (The string is displayed n times).
	//
	//
	//Convert the parameters for disp_text.
	if (0 != (HTuple(hv_Row == HTuple()).TupleOr(hv_Column == HTuple())))
	{
		return;
	}
	if (0 != (hv_Row == -1))
	{
		hv_Row = 12;
	}
	if (0 != (hv_Column == -1))
	{
		hv_Column = 12;
	}
	//
	//Convert the parameter Box to generic parameters.
	hv_GenParamName = HTuple();
	hv_GenParamValue = HTuple();
	if (0 != ((hv_Box.TupleLength()) > 0))
	{
		if (0 != (HTuple(hv_Box[0]) == HTuple("false")))
		{
			//Display no box
			hv_GenParamName = hv_GenParamName.TupleConcat("box");
			hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
		}
		else if (0 != (HTuple(hv_Box[0]) != HTuple("true")))
		{
			//Set a color other than the default.
			hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
			hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[0]));
		}
	}
	if (0 != ((hv_Box.TupleLength()) > 1))
	{
		if (0 != (HTuple(hv_Box[1]) == HTuple("false")))
		{
			//Display no shadow.
			hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
			hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
		}
		else if (0 != (HTuple(hv_Box[1]) != HTuple("true")))
		{
			//Set a shadow color other than the default.
			hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
			hv_GenParamValue = hv_GenParamValue.TupleConcat(HTuple(hv_Box[1]));
		}
	}
	//Restore default CoordSystem behavior.
	if (0 != (hv_CoordSystem != HTuple("window")))
	{
		hv_CoordSystem = "image";
	}
	//
	if (0 != (hv_Color == HTuple("")))
	{
		//disp_text does not accept an empty string for Color.
		hv_Color = HTuple();
	}
	//
	DispText(hv_WindowHandle, hv_String, hv_CoordSystem, hv_Row, hv_Column, hv_Color,
		hv_GenParamName, hv_GenParamValue);
	return;
}

// Chapter: XLD / Creation
// Short Description: Creates an arrow shaped XLD contour. 
void gen_arrow_contour_xld(HObject* ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
	HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
{

	// Local iconic variables
	HObject  ho_TempArrow;

	// Local control variables
	HTuple  hv_Length, hv_ZeroLengthIndices, hv_DR;
	HTuple  hv_DC, hv_HalfHeadWidth, hv_RowP1, hv_ColP1, hv_RowP2;
	HTuple  hv_ColP2, hv_Index;

	//This procedure generates arrow shaped XLD contours,
	//pointing from (Row1, Column1) to (Row2, Column2).
	//If starting and end point are identical, a contour consisting
	//of a single point is returned.
	//
	//input parameteres:
	//Row1, Column1: Coordinates of the arrows' starting points
	//Row2, Column2: Coordinates of the arrows' end points
	//HeadLength, HeadWidth: Size of the arrow heads in pixels
	//
	//output parameter:
	//Arrow: The resulting XLD contour
	//
	//The input tuples Row1, Column1, Row2, and Column2 have to be of
	//the same length.
	//HeadLength and HeadWidth either have to be of the same length as
	//Row1, Column1, Row2, and Column2 or have to be a single element.
	//If one of the above restrictions is violated, an error will occur.
	//
	//
	//Init
	GenEmptyObj(&(*ho_Arrow));
	//
	//Calculate the arrow length
	DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, &hv_Length);
	//
	//Mark arrows with identical start and end point
	//(set Length to -1 to avoid division-by-zero exception)
	hv_ZeroLengthIndices = hv_Length.TupleFind(0);
	if (0 != (hv_ZeroLengthIndices != -1))
	{
		hv_Length[hv_ZeroLengthIndices] = -1;
	}
	//
	//Calculate auxiliary variables.
	hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
	hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
	hv_HalfHeadWidth = hv_HeadWidth / 2.0;
	//
	//Calculate end points of the arrow head.
	hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
	hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
	hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
	hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
	//
	//Finally create output XLD contour for each input point pair
	{
		HTuple end_val45 = (hv_Length.TupleLength()) - 1;
		HTuple step_val45 = 1;
		for (hv_Index = 0; hv_Index.Continue(end_val45, step_val45); hv_Index += step_val45)
		{
			if (0 != (HTuple(hv_Length[hv_Index]) == -1))
			{
				//Create_ single points for arrows with identical start and end point
				GenContourPolygonXld(&ho_TempArrow, HTuple(hv_Row1[hv_Index]), HTuple(hv_Column1[hv_Index]));
			}
			else
			{
				//Create arrow contour
				GenContourPolygonXld(&ho_TempArrow, ((((HTuple(hv_Row1[hv_Index]).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP1[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index]))).TupleConcat(HTuple(hv_RowP2[hv_Index]))).TupleConcat(HTuple(hv_Row2[hv_Index])),
					((((HTuple(hv_Column1[hv_Index]).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP1[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index]))).TupleConcat(HTuple(hv_ColP2[hv_Index]))).TupleConcat(HTuple(hv_Column2[hv_Index])));
			}
			ConcatObj((*ho_Arrow), ho_TempArrow, &(*ho_Arrow));
		}
	}
	return;
}

// Local procedures 
void plot_histo(HTuple hv_Histogram, HTuple hv_WindowHandle, HTuple hv_LabelX, HTuple hv_ValueXMin,
	HTuple hv_ValueXMax, HTuple hv_ColorAxis, HTuple hv_ColorGraph, HTuple hv_Border)
{

	// Local iconic variables
	HObject  ho_Histo, ho_ArrowX, ho_ArrowY;

	// Local control variables
	HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2;
	HTuple  hv_PlotAreaX, hv_PlotAreaY, hv_OriginX, hv_OriginY;
	HTuple  hv_MinY, hv_MaxY, hv_ScaleX, hv_ScaleY, hv_polyX;
	HTuple  hv_polyY, hv_Value, hv_Ascent, hv_Descent, hv_W;
	HTuple  hv_H, hv_MinXD, hv_Ascent1, hv_Descent1, hv_MaxXD;
	HTuple  hv_Ascent2, hv_Descent2, hv_Ascent3, hv_Descent3;
	HTuple  hv_Ascent4, hv_Descent4;

	//This procedure plots the Histogram within the value range
	//[LabelXMin,LabelXMax] into the WindowHandle by leaving a
	//relative Border around the plot.
	//
	if (0 != (HTuple(HTuple((hv_Histogram.TupleLength()) <= 0).TupleOr(hv_Border < 0)).TupleOr(hv_Border >= 1)))
	{
		disp_message(hv_WindowHandle, "Failed to plot histogram", "window", 12, 12, "black",
			"true");
		return;
	}
	//
	//Determine the area to be used for the plot.
	GetPart(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
	hv_PlotAreaX = ((hv_Column2 - hv_Column1) + 1) * (1 - (hv_Border * 2));
	hv_PlotAreaY = ((hv_Row2 - hv_Row1) + 1) * (1 - (hv_Border * 2));
	hv_OriginX = hv_Column1 + (hv_Border * ((hv_Column2 - hv_Column1) + 1));
	hv_OriginY = hv_Row2 - (hv_Border * ((hv_Row2 - hv_Column1) + 1));
	//
	//Determine the extent of the function to be plotted
	hv_MinY = (hv_Histogram.TupleConcat(0)).TupleMin();
	hv_MaxY = hv_Histogram.TupleMax();
	//
	//Determine the scaling values
	hv_ScaleX = hv_PlotAreaX / (hv_Histogram.TupleLength());
	if (0 != (hv_MaxY == hv_MinY))
	{
		hv_ScaleY = hv_PlotAreaY;
		hv_MaxY = "";
	}
	else
	{
		hv_ScaleY = hv_PlotAreaY / (hv_MaxY - hv_MinY);
	}
	//
	//Display the histogram values
	hv_polyX = HTuple();
	hv_polyY = HTuple();
	{
		HTuple end_val32 = (hv_Histogram.TupleLength()) - 1;
		HTuple step_val32 = 1;
		for (hv_Value = 0; hv_Value.Continue(end_val32, step_val32); hv_Value += step_val32)
		{
			hv_polyX = hv_polyX.TupleConcat(hv_OriginX + (hv_Value * hv_ScaleX));
			hv_polyY = hv_polyY.TupleConcat(hv_OriginY - ((HTuple(hv_Histogram[hv_Value]) - hv_MinY) * hv_ScaleY));
			hv_polyX = hv_polyX.TupleConcat(hv_OriginX + ((hv_Value + 1) * hv_ScaleX));
			hv_polyY = hv_polyY.TupleConcat(hv_OriginY - ((HTuple(hv_Histogram[hv_Value]) - hv_MinY) * hv_ScaleY));
		}
	}
	hv_polyX = (hv_polyX.TupleConcat(hv_OriginX + ((hv_Histogram.TupleLength()) * hv_ScaleX))).TupleConcat(hv_OriginX);
	hv_polyY = (hv_polyY.TupleConcat(hv_OriginY)).TupleConcat(hv_OriginY);
	HDevWindowStack::SetActive(hv_WindowHandle);
	if (HDevWindowStack::IsOpen())
		SetLineWidth(HDevWindowStack::GetActive(), 1);
	if (HDevWindowStack::IsOpen())
		SetColor(HDevWindowStack::GetActive(), hv_ColorGraph);
	GenRegionPolygonFilled(&ho_Histo, hv_polyY, hv_polyX);
	if (HDevWindowStack::IsOpen())
		DispObj(ho_Histo, HDevWindowStack::GetActive());
	//
	//Display the coordinate system
	if (HDevWindowStack::IsOpen())
		SetLineWidth(HDevWindowStack::GetActive(), 1);
	if (HDevWindowStack::IsOpen())
		SetColor(HDevWindowStack::GetActive(), hv_ColorAxis);
	gen_arrow_contour_xld(&ho_ArrowX, hv_OriginY, hv_OriginX, hv_OriginY, hv_OriginX + hv_PlotAreaX,
		5, 5);
	gen_arrow_contour_xld(&ho_ArrowY, hv_OriginY, hv_OriginX, hv_OriginY - hv_PlotAreaY,
		hv_OriginX, 5, 5);
	if (HDevWindowStack::IsOpen())
		DispObj(ho_ArrowX, HDevWindowStack::GetActive());
	if (HDevWindowStack::IsOpen())
		DispObj(ho_ArrowY, HDevWindowStack::GetActive());
	//
	if (HDevWindowStack::IsOpen())
		SetColor(HDevWindowStack::GetActive(), hv_ColorAxis);
	GetStringExtents(hv_WindowHandle, hv_LabelX, &hv_Ascent, &hv_Descent, &hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY + 10, (hv_OriginX + (hv_PlotAreaX / 2)) - (hv_W / 2));
	WriteString(hv_WindowHandle, hv_LabelX);
	//
	if (0 != ((hv_ValueXMin.TupleInt()) == hv_ValueXMin))
	{
		hv_MinXD = hv_ValueXMin.TupleInt();
	}
	else
	{
		hv_MinXD = hv_ValueXMin;
	}
	GetStringExtents(hv_WindowHandle, hv_MinXD.TupleString("3.1f"), &hv_Ascent1, &hv_Descent1,
		&hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY + 10, hv_OriginX);
	WriteString(hv_WindowHandle, hv_MinXD.TupleString("3.1f"));
	if (0 != ((hv_ValueXMax.TupleInt()) == hv_ValueXMax))
	{
		hv_MaxXD = hv_ValueXMax.TupleInt();
	}
	else
	{
		hv_MaxXD = hv_ValueXMax;
	}
	GetStringExtents(hv_WindowHandle, hv_MaxXD.TupleString("3.1f"), &hv_Ascent2, &hv_Descent2,
		&hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY + 10, (hv_OriginX + hv_PlotAreaX) - hv_W);
	WriteString(hv_WindowHandle, hv_MaxXD.TupleString("3.1f"));
	GetStringExtents(hv_WindowHandle, hv_MinY, &hv_Ascent3, &hv_Descent3, &hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY - hv_H, (hv_OriginX - 10) - hv_W);
	WriteString(hv_WindowHandle, hv_MinY);
	GetStringExtents(hv_WindowHandle, hv_MaxY, &hv_Ascent4, &hv_Descent4, &hv_W, &hv_H);
	SetTposition(hv_WindowHandle, hv_OriginY - hv_PlotAreaY, (hv_OriginX - 10) - hv_W);
	WriteString(hv_WindowHandle, hv_MaxY);
	//
	return;
}

void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold,
	HTuple hv_Slant)
{

	// Local iconic variables

	// Local control variables
	HTuple  hv_OS, hv_Fonts, hv_Style, hv_Exception;
	HTuple  hv_AvailableFonts, hv_Fdx, hv_Indices;

	//This procedure sets the text font of the current window with
	//the specified attributes.
	//
	//Input parameters:
	//WindowHandle: The graphics window for which the font will be set
	//Size: The font size. If Size=-1, the default of 16 is used.
	//Bold: If set to 'true', a bold font is used
	//Slant: If set to 'true', a slanted font is used
	//
	GetSystem("operating_system", &hv_OS);
	if (0 != (HTuple(hv_Size == HTuple()).TupleOr(hv_Size == -1)))
	{
		hv_Size = 16;
	}
	if (0 != ((hv_OS.TupleSubstr(0, 2)) == HTuple("Win")))
	{
		//Restore previous behaviour
		hv_Size = (1.13677 * hv_Size).TupleInt();
	}
	else
	{
		hv_Size = hv_Size.TupleInt();
	}
	if (0 != (hv_Font == HTuple("Courier")))
	{
		hv_Fonts.Clear();
		hv_Fonts[0] = "Courier";
		hv_Fonts[1] = "Courier 10 Pitch";
		hv_Fonts[2] = "Courier New";
		hv_Fonts[3] = "CourierNew";
		hv_Fonts[4] = "Liberation Mono";
	}
	else if (0 != (hv_Font == HTuple("mono")))
	{
		hv_Fonts.Clear();
		hv_Fonts[0] = "Consolas";
		hv_Fonts[1] = "Menlo";
		hv_Fonts[2] = "Courier";
		hv_Fonts[3] = "Courier 10 Pitch";
		hv_Fonts[4] = "FreeMono";
		hv_Fonts[5] = "Liberation Mono";
	}
	else if (0 != (hv_Font == HTuple("sans")))
	{
		hv_Fonts.Clear();
		hv_Fonts[0] = "Luxi Sans";
		hv_Fonts[1] = "DejaVu Sans";
		hv_Fonts[2] = "FreeSans";
		hv_Fonts[3] = "Arial";
		hv_Fonts[4] = "Liberation Sans";
	}
	else if (0 != (hv_Font == HTuple("serif")))
	{
		hv_Fonts.Clear();
		hv_Fonts[0] = "Times New Roman";
		hv_Fonts[1] = "Luxi Serif";
		hv_Fonts[2] = "DejaVu Serif";
		hv_Fonts[3] = "FreeSerif";
		hv_Fonts[4] = "Utopia";
		hv_Fonts[5] = "Liberation Serif";
	}
	else
	{
		hv_Fonts = hv_Font;
	}
	hv_Style = "";
	if (0 != (hv_Bold == HTuple("true")))
	{
		hv_Style += HTuple("Bold");
	}
	else if (0 != (hv_Bold != HTuple("false")))
	{
		hv_Exception = "Wrong value of control parameter Bold";
		throw HException(hv_Exception);
	}
	if (0 != (hv_Slant == HTuple("true")))
	{
		hv_Style += HTuple("Italic");
	}
	else if (0 != (hv_Slant != HTuple("false")))
	{
		hv_Exception = "Wrong value of control parameter Slant";
		throw HException(hv_Exception);
	}
	if (0 != (hv_Style == HTuple("")))
	{
		hv_Style = "Normal";
	}
	QueryFont(hv_WindowHandle, &hv_AvailableFonts);
	hv_Font = "";
	{
		HTuple end_val48 = (hv_Fonts.TupleLength()) - 1;
		HTuple step_val48 = 1;
		for (hv_Fdx = 0; hv_Fdx.Continue(end_val48, step_val48); hv_Fdx += step_val48)
		{
			hv_Indices = hv_AvailableFonts.TupleFind(HTuple(hv_Fonts[hv_Fdx]));
			if (0 != ((hv_Indices.TupleLength()) > 0))
			{
				if (0 != (HTuple(hv_Indices[0]) >= 0))
				{
					hv_Font = HTuple(hv_Fonts[hv_Fdx]);
					break;
				}
			}
		}
	}
	if (0 != (hv_Font == HTuple("")))
	{
		throw HException("Wrong value of control parameter Font");
	}
	hv_Font = (((hv_Font + "-") + hv_Style) + "-") + hv_Size;
	SetFont(hv_WindowHandle, hv_Font);
	return;
}
// 获取指定路径下的所有文件路径和文件名
void getFiles(string path, vector<string>& filepaths, vector<string>& filenames)//&表引用,相当于给现有变量起个别名
{
	/*files存储文件的路径及名称(eg.C:\Users\WUQP\Desktop\test_devided\data1.txt)
	ownname只存储文件的名称(eg.data1.txt)*/
	long hFile = 0;//文件句柄;
	struct _finddata_t fileinfo;//文件信息; Struct _finddata_t是用来存储文件各种信息的结构体
	/*struct _finddata_t
		{
			 unsigned attrib;           //文件属性的存储位置
			 time_t time_create;        //保存从1970年1月1日0时0分0秒到现在时刻的秒数
			 time_t time_access;        //文件最后一次被访问的时间
			 time_t time_write;         //文件最后一次被修改的时间
			 _fsize_t size;             //文件的大小（字节数表示）
			 char name[_MAX_FNAME];     //文件的文件名
		};*/
	string p;

	hFile = _findfirst(p.assign(path).append("\\*.jpg").c_str(), &fileinfo);//查找文件，如果查找成功的话，将返回一个long型的唯一的查找用的句柄（就是一个唯一编号）；若失败，则返回-1
	if (hFile != -1)
	{
		do
		{
			filenames.push_back(fileinfo.name);
			filepaths.push_back(path + "/" + fileinfo.name);
		} while (_findnext(hFile, &fileinfo) == 0);//_findnext若成功返回0，否则返回-1
	}
	_findclose(hFile);//关闭句柄 
}
//获取当前工作路径
void getCurrentPath(string& path)
{
	char* buffer;
	if ((buffer = _getcwd(NULL, 0)) == NULL)
		perror("_getcwd error");
	else
	{
		path = buffer;
		free(buffer);
	}
}

// 滤波并保存
// save_path表示保存路径，image表示要处理的图片
// row和column表示滤波器大小，默认50*50
HObject meanImage(string save_path, HObject image, int row=50, int column=50)
{
	string save_ori = save_path + ".png";//保存原图
	save_path = save_path + "_meaIm.png";
	HObject ho_ImageMean;  // 滤波后的图片
	HTuple h_save_path(save_path.c_str());  // 数据类型转换

	
	MeanImage(image, &ho_ImageMean, row, column);

	WriteImage(ho_ImageMean, "png", 0, h_save_path.S());

	h_save_path = save_ori.c_str();
	WriteImage(image, "png", 0, h_save_path.S());
	return ho_ImageMean;
}

// 中值滤波并保存
// save_path表示保存路径，image表示要处理的图片
// row和column表示滤波器大小，默认50*50
HObject medianImage(string save_path, HObject image, int row = 50)
{
	save_path = save_path + "_median.png";
	HObject ho_ImageMedian;  // 滤波后的图片
	HTuple h_save_path(save_path.c_str());  // 数据类型转换

	
	MedianImage(image, &ho_ImageMedian, "square", row, "mirrored");
	WriteImage(ho_ImageMedian, "png", 0, h_save_path.S());
	return ho_ImageMedian;
}

// 直接阈值化并保存

// string save_path,表示保存的路径； HObject image表示要阈值化的图片
void binaryMeanImage(string save_path, HObject image)
{
	save_path = save_path + "_2M";
	HTuple h_save_path(save_path.c_str());  // 数据类型转换
	HTuple hv_UsedThreshold;
	HObject  ho_Image1;
	HTuple  hv_Area, hv_Row, hv_Column, hv_Area1, hv_rate, hv_Width, hv_Height;
	HObject  ho_Region1;
	BinaryThreshold(image, &ho_Region1, "max_separability", "dark", &hv_UsedThreshold);  // 二值化输入图片
	// 计算面积比率
	AreaCenter(image, &hv_Area, &hv_Row, &hv_Column);
	AreaCenter(ho_Region1, &hv_Area1, &hv_Row, &hv_Column);
	hv_rate = (hv_Area1 * 100) / hv_Area;
	h_save_path = h_save_path.S() + hv_rate + "%.png";
	GetImageSize(image, &hv_Width, &hv_Height);
	RegionToBin(ho_Region1, &ho_Image1, 255, 0, hv_Width, hv_Height);
	WriteImage(ho_Image1, "png", 0, h_save_path.S());

}
// 滤波后直接阈值化之后进行形态学分析并保存
// string save_path,表示存储路径； HObject image, 表示要阈值化的图片；int radius=25 表示圆形闭运算的半径
void blobBinaryMeanImage(string save_path, HObject image, int radius=25)
{
	save_path = save_path + "_BM";
	HTuple h_save_path(save_path.c_str());  // 数据类型转换
	HObject  ho_RegionClosing, ho_RegionFillUp, region, ho_Region1, ho_Image1;
	HTuple  hv_UsedThreshold, hv_Area, hv_Row, hv_Column, hv_Area1, hv_rate;
	BinaryThreshold(image, &ho_Region1, "max_separability", "dark", &hv_UsedThreshold);  // 二值化输入图片
	ClosingCircle(ho_Region1, &ho_RegionClosing, radius);
	FillUp(ho_RegionClosing, &ho_RegionFillUp);
	//特征计算
	AreaCenter(image, &hv_Area, &hv_Row, &hv_Column);  // 整张图片大小
	AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row, &hv_Column);  //Blob分析之后识别区域大小
	hv_rate = (hv_Area1 * 100) / hv_Area;
	h_save_path = h_save_path.S()  + hv_rate + "%.png";
	GetImageSize(image, &hv_Row, &hv_Column);
	RegionToBin(ho_Region1, &ho_Image1, 255, 0, hv_Row, hv_Column);
	WriteImage(ho_Image1, "png", 0, h_save_path.S());
}
// 计算灰度直方图并保存
// 需要传入窗口值
void histo(string save_path, HObject image)
{
	HTuple hv_WindowHandle, hv_Width, hv_Height;
	save_path = save_path + "_ghist.png";
	HTuple h_save_path(save_path.c_str());  // 数据类型转换
	HTuple hv_HistoBorder, hv_Min, hv_Max, hv_Range, hv_Histo, hv_BinSize;
	HObject ho_Image1, ho_GrayImage;
	// 打开一个窗口
	GetImageSize(image, &hv_Width, &hv_Height);
	SetWindowAttr("background_color", "black");
	OpenWindow(0, 0, hv_Width, hv_Height, 0, "visible", "", &hv_WindowHandle);
	HDevWindowStack::Push(hv_WindowHandle);
	// 显示并保存灰度直方图
	hv_HistoBorder = 0.1;
	Rgb1ToGray(image, &ho_GrayImage);
	// 清空窗口
	if (HDevWindowStack::IsOpen())
		ClearWindow(HDevWindowStack::GetActive());
	// set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
	MinMaxGray(image, image, 0, &hv_Min, &hv_Max, &hv_Range);
	GrayHistoRange(ho_GrayImage, ho_GrayImage, 0, 255, 256, &hv_Histo, &hv_BinSize);
	plot_histo(hv_Histo, hv_WindowHandle, "Gray values", 0, 255, "white", "red", hv_HistoBorder);
	DumpWindowImage(&ho_Image1, hv_WindowHandle);
	WriteImage(ho_Image1, "png", 0, h_save_path.S());
	if (HDevWindowStack::IsOpen())
		CloseWindow(HDevWindowStack::Pop());
}
// 颜色空间转换
// 参数地址 返回三个分量并保存到指定路径
void rgbToHsv(string save_path, HObject ho_Image, HObject& ho_Hue, HObject& ho_Saturation, HObject& ho_Intensity, bool save=1)
{

	HObject ho_Red, ho_Green, ho_Blue;
	HTuple h_save_path;  // 数据类型转换

	Decompose3(ho_Image, &ho_Red, &ho_Green, &ho_Blue);
	TransFromRgb(ho_Red, ho_Green, ho_Blue, &ho_Hue, &ho_Saturation, &ho_Intensity, "hsv");
	if (save)
	{
		string temp = save_path;
		// ho_Hue分量
		save_path = temp + "_HueIg.png";  // 最终输出

		h_save_path = save_path.c_str();  // 保存图片的路径

		WriteImage(ho_Hue, "png", 0, h_save_path.S());
		//ho_Saturation
		save_path = temp + "_SatIg.png";  // 最终输出

		h_save_path = save_path.c_str();  // 保存图片的路径

		WriteImage(ho_Saturation, "png", 0, h_save_path.S());
		// ho_Intensity
		save_path = temp + "_IntIg.png";  // 最终输出

		h_save_path = save_path.c_str();  // 保存图片的路径

		WriteImage(ho_Intensity, "png", 0, h_save_path.S());
	}
	

}
/*************************函数说明*******************
* 函数名称:binaryHue()
* 函数功能：对颜色空间转换后的Hue分量做阈值化分析
* 函数参数：
	string save_path：表示保存路径
	HObject ho_Hue： 表示传入的Hue分量
	HTuple hv_Area,：表示原图像的面积
	HTuple hv_Width：表示原图像的宽（width）
	HTuple hv_Height：表示原图像的高（height）

*/
void binaryHue(string save_path, HObject ho_Hue, HTuple hv_Area, HTuple hv_Width, HTuple hv_Height)
{
	HTuple h_save_path, hv_UsedThreshold, hv_Area1, hv_Row1, hv_Column1, hv_rate;  // 数据类型转换
	HObject ho_Region, ho_RegionClosing, ho_RegionFillUp, ho_Image;

	// 阈值化
	BinaryThreshold(ho_Hue, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);

	//BLOB分析
	ClosingCircle(ho_Region, &ho_RegionClosing, 25);
	FillUp(ho_RegionClosing, &ho_RegionFillUp);

	//特征计算
	AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
	hv_rate = (hv_Area1 * 100) / hv_Area;

	save_path = save_path + "_BH";
	h_save_path = save_path.c_str();
	h_save_path = h_save_path.S() + hv_rate + "%.png";
	RegionToBin(ho_Region, &ho_Image, 255, 0, hv_Width, hv_Height);
	WriteImage(ho_Image, "png", 0, h_save_path.S());
}

/*************************函数说明*******************
* 函数名称:binarySaturation()
* 函数功能：对颜色空间转换后的Saturation分量做阈值化分析
* 函数参数：
	string save_path：表示保存路径
	HObject ho_Hue： 表示传入的Hue分量
	HTuple hv_Area,：表示原图像的面积
	HTuple hv_Width：表示原图像的宽（width）
	HTuple hv_Height：表示原图像的高（height）

*/
void binarySaturation(string save_path, HObject ho_Saturation, HTuple hv_Area, HTuple hv_Width, HTuple hv_Height)
{
	HTuple  hv_UsedThreshold, hv_Area1, hv_Row1, hv_Column1, hv_rate;  // 数据类型转换
	HObject ho_Region, ho_RegionClosing, ho_RegionFillUp, ho_Image;

	// 阈值化
	BinaryThreshold(ho_Saturation, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);

	//BLOB分析
	ClosingCircle(ho_Region, &ho_RegionClosing, 25);
	FillUp(ho_RegionClosing, &ho_RegionFillUp);

	//特征计算
	AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
	hv_rate = (hv_Area1 * 100) / hv_Area;

	save_path = save_path + "_bS";
	HTuple h_save_path(save_path.c_str());
	h_save_path = h_save_path.S() + hv_rate + "%.png";
	RegionToBin(ho_Region, &ho_Image, 255, 0, hv_Width, hv_Height);
	WriteImage(ho_Image, "png", 0, h_save_path.S());
}

/*************************函数说明*******************
* 函数名称:binaryIntensity()
* 函数功能：对颜色空间转换后的Intensity分量做阈值化分析
* 函数参数：
	string save_path：表示保存路径
	HObject ho_Hue： 表示传入的Hue分量
	HTuple hv_Area,：表示原图像的面积
	HTuple hv_Width：表示原图像的宽（width）
	HTuple hv_Height：表示原图像的高（height）

*/
void binaryIntensity(string save_path, HObject ho_Intensity, HTuple hv_Area, HTuple hv_Width, HTuple hv_Height)
{
	HTuple h_save_path, hv_UsedThreshold, hv_Area1, hv_Row1, hv_Column1, hv_rate;  // 数据类型转换
	HObject ho_Region, ho_RegionClosing, ho_RegionFillUp, ho_Image;

	// 阈值化
	BinaryThreshold(ho_Intensity, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);

	//BLOB分析
	ClosingCircle(ho_Region, &ho_RegionClosing, 25);
	FillUp(ho_RegionClosing, &ho_RegionFillUp);

	//特征计算
	AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
	hv_rate = (hv_Area1 * 100) / hv_Area;

	save_path = save_path + "_BI";
	h_save_path = save_path.c_str();
	h_save_path = h_save_path.S() + hv_rate + "%.png";
	RegionToBin(ho_Region, &ho_Image, 255, 0, hv_Width, hv_Height);
	WriteImage(ho_Image, "png", 0, h_save_path.S());
}

/*************************函数说明*******************
* 函数名称:concrete()
* 对应模式：Model=1
* 函数功能：主要实现对已喷区域完善性的检测
* 函数参数：
	string save_path：表示保存路径
	HObject image： 表示传入原始的图片
	HTuple Width :表示原始图片宽
	HTuple Height：表示原始图片高

*/
void concrete(string save_path, HObject image, HTuple hv_Width, HTuple hv_Height)
{
	save_path = save_path + "_re";
	// Local iconic variables
	HObject  ho_Image, ho_GrayImage, ho_Edges, ho_SelectedXLD;
	HObject  ho_Region, ho_UnionContours, ho_BinImage;

	// Local control variables
	
	HTuple  hv_Area1, hv_Row1, hv_Column1, hv_PointOrder,hv_Area,hv_rate,h_save_path;
	try 
	{
		Rgb1ToGray(image, &ho_GrayImage);
		//边缘提取
		EdgesSubPix(ho_GrayImage, &ho_Edges, "canny", 1, 20, 40);
		SelectShapeXld(ho_Edges, &ho_SelectedXLD, (HTuple("area").Append("height")), "and",
			(HTuple(46.45).Append(26.572)), (HTuple(500).Append(100)));
		AreaCenterXld(ho_SelectedXLD, &hv_Area1, &hv_Row1, &hv_Column1, &hv_PointOrder);
		//判断是否有需要重新喷的区域
		if (0 != ((hv_Area1.TupleLength()) == 0))
		{
			GenRectangle1(&ho_Region, 0, 0, hv_Height - 1, hv_Width - 1);
			hv_Area1 = 0;
			RegionToBin(ho_Region, &ho_BinImage, 0, 0, hv_Width, hv_Height);
		}
		else
		{
			UnionCollinearContoursXld(ho_SelectedXLD, &ho_UnionContours, 60, 20, 10, 0.2,
				"attr_forget");
			GenRegionContourXld(ho_UnionContours, &ho_Region, "filled");
			AreaCenter(ho_Region, &hv_Area1, &hv_Row1, &hv_Column1);
			RegionToBin(ho_Region, &ho_BinImage, 255, 0, hv_Width, hv_Height);
		}
		//特征计算
		AreaCenter(image, &hv_Area, &hv_Row1, &hv_Column1);  // 整张图片大小

		hv_rate = (hv_Area1 * 100) / hv_Area;
		h_save_path = save_path.c_str();
		h_save_path = h_save_path.S() + hv_rate + "%.png";

		WriteImage(ho_BinImage, "png", 0, h_save_path.S());
	}
	catch (exception e)
	{
		cerr << "When dealing with the class of CONCRETE, error!!!" << endl;
		cerr << &e << endl;
	}
	
}

/*************************函数说明*******************
* 函数名称:rebarConcrete()
* 对应模式：Model=2
* 函数功能：对钢筋下面没有水泥的区域进行识别
* 函数参数：
	string save_path：表示保存路径
	HObject image： 表示传入原始的图片
	HTuple Width :表示原始图片宽
	HTuple Height：表示原始图片高

*/
void rebarConcrete(string save_path, HObject image, HTuple Width, HTuple Height)
{
	save_path = save_path + "_re";
	
	// Local iconic variables
	HObject  ho_GrayImage, ho_GrayRegion1;
	HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_RegionUnion1;
	HObject  ho_Rectangle, ho_RegionClosing1, ho_Rectangle2;
	HObject  ho_RegionClosing2, ho_Bi_Gr_Cl_Fi_Region, ho_BinImage;

	// Local control variables
	HTuple  hv_Width, hv_Height, hv_UsedThreshold1,hv_Area,hv_rate,hv_Area1;
	HTuple hv_save_path(save_path.c_str());
	try
	{
		//灰度处理
		Rgb1ToGray(image, &ho_GrayImage);
		//直接阈值化
		BinaryThreshold(ho_GrayImage, &ho_GrayRegion1, "max_separability", "dark", &hv_UsedThreshold1);
		Connection(ho_GrayRegion1, &ho_ConnectedRegions);

		SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 224.55, 500000);
		Union1(ho_SelectedRegions, &ho_RegionUnion1);

		GenRectangle2(&ho_Rectangle, 10, 10, 0, 5, 10);
		Closing(ho_RegionUnion1, ho_Rectangle, &ho_RegionClosing1);
		GenRectangle2(&ho_Rectangle2, 10, 10, 0, 10, 5);
		Closing(ho_RegionClosing1, ho_Rectangle2, &ho_RegionClosing2);

		FillUp(ho_RegionClosing2, &ho_Bi_Gr_Cl_Fi_Region);
		//特征计算
		AreaCenter(image, &hv_Area, &hv_Width, &hv_Height);  // 整张图片大小
		AreaCenter(ho_Bi_Gr_Cl_Fi_Region, &hv_Area1, &hv_Width, &hv_Height);  //Blob分析之后识别区域大小
		hv_rate = (hv_Area1 * 100) / hv_Area;

		
		hv_save_path = hv_save_path.S() + hv_rate + "%.png";
		RegionToBin(ho_Bi_Gr_Cl_Fi_Region, &ho_BinImage, 255, 0, Width, Height);
		WriteImage(ho_BinImage, "png", 0, hv_save_path.S());
	}
	catch (exception e)
	{
		cerr << "Error when dealing with the class of rebar concrete" << endl;
		cerr << &e << endl;
	}

}

/*************************函数说明*******************
* 函数名称:rebarRock()
* 对应模式：Model=3
* 函数功能：对有岩石的钢筋处进行识别，主要思路是提取其钢架骨架的边缘直线，形成矩形覆盖
* 函数参数：
	string save_path：表示保存路径
	HObject image： 表示传入原始的图片
	HTuple Width :表示原始图片宽
	HTuple Height：表示原始图片高

*/
void rebarRock(string save_path, HObject image, HTuple hv_Width, HTuple hv_Height)
{
	save_path = save_path + "_re";
	// Local iconic variables
	HObject  ho_Image, ho_GrayImage, ho_Edges, ho_SelectedXLD1;
	HObject  ho_UnionContours, ho_SelectedXLD2, ho_Rectangle;
	HObject  ho_BinImage, ho_Rectangle1, ho_BinImage1;

	// Local control variables
	
	HTuple  hv_Area, hv_Row, hv_Column, hv_column1, hv_row1;
	HTuple  hv_row2, hv_column2, hv_Index, hv_temp,hv_rate,hv_Area1;
	HTuple hv_path(save_path.c_str());

	try
	{
		Rgb1ToGray(image, &ho_GrayImage);
		//边缘提取
		EdgesSubPix(ho_GrayImage, &ho_Edges, "canny", 1, 20, 40);
		SelectShapeXld(ho_Edges, &ho_SelectedXLD1, "height", "and", 20.77, 500);
		UnionCollinearContoursXld(ho_SelectedXLD1, &ho_UnionContours, 60, 20, 10, 0.2,
			"attr_forget");
		SelectShapeXld(ho_UnionContours, &ho_SelectedXLD2, "height", "and", 186, 500);


		AreaCenterPointsXld(ho_SelectedXLD2, &hv_Area, &hv_Row, &hv_Column);
		//找到相隔最远的两条直线
		if (0 != ((hv_Column.TupleLength()) <= 1))
		{
			GenRectangle1(&ho_Rectangle, 0, 0, hv_Height - 1, hv_Width - 1);
			RegionToBin(ho_Rectangle, &ho_BinImage, 255, 0, hv_Width, hv_Height);
			save_path = save_path + "100%.png";
			hv_path = save_path.c_str();
			WriteImage(ho_BinImage, "png", 0, hv_path.S());
		}
		else
		{
			hv_column1 = 0;
			hv_row1 = 0;
			hv_row2 = ((const HTuple&)hv_Row)[0];
			hv_column2 = ((const HTuple&)hv_Column)[0];
			{
				HTuple end_val29 = (hv_Column.TupleLength()) - 1;
				HTuple step_val29 = 1;
				for (hv_Index = 0; hv_Index.Continue(end_val29, step_val29); hv_Index += step_val29)
				{
					hv_temp = HTuple(hv_Column[hv_Index]);

					if (0 != (hv_temp > hv_column1))
					{
						hv_column1 = hv_temp;
						hv_row1 = HTuple(hv_Row[hv_Index]);
					}
					if (0 != (hv_temp < hv_column2))
					{
						hv_column2 = hv_temp;
						hv_row2 = HTuple(hv_Row[hv_Index]);
					}
				}
			}
			GenRectangle2(&ho_Rectangle1, (hv_row1 + hv_row2) / 2, (hv_column1 + hv_column2) / 2,
				0, (hv_column1 - hv_column2) / 2, (hv_row1 + hv_row2) / 2);

			//特征计算
			AreaCenter(image, &hv_Area, &hv_Row, &hv_Column);  // 整张图片大小
			AreaCenter(ho_Rectangle1, &hv_Area1, &hv_Row, &hv_Column);  //Blob分析之后识别区域大小
			hv_rate = (hv_Area1 * 100) / hv_Area;
			hv_path = hv_path.S() + hv_rate + "%.png";
			RegionToBin(ho_Rectangle1, &ho_BinImage1, 255, 0, hv_Width, hv_Height);
			WriteImage(ho_BinImage1, "png", 0, hv_path.S());

		}
	}
	catch(...)
	{
		cerr << "Error when dealing with REBARROCK" << endl;
	}

	
				
			
		
		
	
	

}

/*************************函数说明*******************
* 函数名称:rebarRockConcrete()
* 对应模式：Model=4
* 函数功能：对有环形掌子面的区域进行识别，返回的是Intensity分量的处理结果
* 函数参数：
	string save_path：表示保存路径
	HObject image： 表示传入原始的图片
	HTuple Width :表示原始图片宽
	HTuple Height：表示原始图片高
	int radius：表示圆形开运算的半径
*/
void rebarRockConcrete(string save_path, HObject image, HTuple Width, HTuple Height, int radius = 25)
{
	save_path = save_path + "_re";
	HTuple h_save_path(save_path.c_str());  // 数据类型转换
	HTuple hv_UsedThreshold, hv_Area1, hv_Row1, hv_Column1, hv_rate,hv_Area;  // 数据类型转换
	HObject ho_Region, ho_RegionClosing, ho_RegionFillUp, ho_Image, ho_Red, ho_Green, ho_Blue, ho_Hue, ho_Saturation, ho_Intensity;
	try
	{
		

		rgbToHsv(save_path, image, ho_Hue, ho_Saturation, ho_Intensity, 0);

		// 阈值化
		BinaryThreshold(ho_Intensity, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);

		//BLOB分析
		ClosingCircle(ho_Region, &ho_RegionClosing, 25);
		FillUp(ho_RegionClosing, &ho_RegionFillUp);

		//特征计算
		AreaCenter(image, &hv_Area, &hv_Row1, &hv_Column1);  // 整张图片大小
		AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
		hv_rate = (hv_Area1 * 100) / hv_Area;
		//保存
		
		h_save_path = save_path.c_str();
		h_save_path = h_save_path.S() + hv_rate + "%.png";
		RegionToBin(ho_RegionFillUp, &ho_Image, 255, 0, Width, Height);
		WriteImage(ho_Image, "png", 0, h_save_path.S());
	}
	catch (exception r)
	{
		cerr << "Error when dealing with the class of rebar rock concrete" << endl;
		cerr << &r << endl;
	}
	
}

/*************************函数说明*******************
* 函数名称:rock()
* 对应模式：Model=5
* 函数功能：对岩石表面进行处理,Hue分量处理结果
* 函数参数：
	string save_path：表示保存路径
	HObject image： 表示传入原始的图片
	HTuple Width :表示原始图片宽
	HTuple Height：表示原始图片高
	
*/
void rock(string save_path, HObject image, HTuple hv_Width, HTuple hv_Height)
{
	save_path = save_path + "_re";

	HTuple h_save_path, hv_UsedThreshold, hv_Area1, hv_Row1, hv_Column1, hv_rate,hv_Area;  // 数据类型转换
	HObject ho_Region, ho_RegionClosing, ho_RegionFillUp, ho_Image, ho_Red, ho_Green, ho_Blue, ho_Hue, ho_Saturation, ho_Intensity;
	try
	{
		rgbToHsv(save_path, image, ho_Hue, ho_Saturation, ho_Intensity, 0);
		// 阈值化
		BinaryThreshold(ho_Hue, &ho_Region, "max_separability", "light", &hv_UsedThreshold);

		//BLOB分析
		ClosingCircle(ho_Region, &ho_RegionClosing, 25);
		FillUp(ho_RegionClosing, &ho_RegionFillUp);

		//特征计算
		AreaCenter(image, &hv_Area, &hv_Row1, &hv_Column1);  // 整张图片大小
		AreaCenter(ho_RegionFillUp, &hv_Area1, &hv_Row1, &hv_Column1);
		hv_rate = (hv_Area1 * 100) / hv_Area;
		//保存
		h_save_path = save_path.c_str();
		h_save_path = h_save_path.S() + hv_rate + "%.png";
		RegionToBin(ho_RegionFillUp, &ho_Image, 255, 0, hv_Width, hv_Height);
		WriteImage(ho_Image, "png", 0, h_save_path.S());
	}
	catch (exception e)
	{
		cerr << "When dealing with the class of ROCK, Error" << endl;
		cerr << &e << endl;

	}

	


	// Local iconic variables
	HObject  ho_BinImage;

	// Local control variables
	HTuple  hv_path;
	save_path = save_path + "00%"; //两种方案

	hv_path = save_path.c_str();
	
	GenRectangle1(&ho_Region, 0, 0, hv_Height - 1, hv_Width - 1);
	RegionToBin(ho_Region, &ho_BinImage, 0, 0, hv_Width, hv_Height);
	WriteImage(ho_BinImage, "png", 0, hv_path.S());
}
#ifndef NO_EXPORT_MAIN
// Main procedure 
extern "C" _declspec(dllexport) void action(int choice,int model)
{

	// Local iconic variables
	HObject  ho_Image, ho_ImageMean;
	
	HObject  ho_Hue, ho_Saturation, ho_Intensity, ho_Region;
	

	// Local control variables
	HTuple  hv_Width, hv_Height, hv_WindowHandle;
	
	HTuple  hv_Area, hv_Row1, hv_Column1, hv_Area1, hv_rate;
		

	//一次处理一张图片
	//每次处理后存储图片
	//dev_update_off();
	//if (HDevWindowStack::IsOpen())
	//	CloseWindow(HDevWindowStack::Pop());
	// 函数参数
	string work_path = "";  // 当前工作路径
	vector<string> file_path;  // 当前工作路径下的所有文件的完整路径，含后缀
	vector<string> filenames;  // 当前工作路径下的所有文件名，仅名字
	// 读取和保存文件路径
	string c_read_path;  // 最终读取文件的路径,C++格式,含文件名
	string c_save_path;  // 存储保存文件的路径，含文件名
	string temp;  // 存储包含不同后缀名的文件保存路径


	// 获取当前工作目录，得到图片读取目录和保存目录

	getCurrentPath(work_path);  // 获取当前路径
	c_save_path = work_path + "\\temp\\processed_img\\";
	string savePath = c_save_path;  // 在for循环后面还原保存路径
	work_path = work_path + "\\temp\\raw_img\\";

	getFiles(work_path, file_path, filenames);  // 获取当前路路径下的所有文件路径和文件名

	try
	{
		if (!file_path.size() || !filenames.size())
		{
			throw "There is nothing in this path!";
		}
		for (int i = 0; i < filenames.size(); i = i + 1)
		{
			c_read_path = work_path + filenames[i]; // 获取第i个图片

			string name = filenames[i].substr(0, filenames[i].length() - 4);  //获取第i个文件名，删除后缀，后缀只能是三个字符，如png，jpg，不兼容jpeg

			c_save_path = savePath + name ;  // 文件，不带后缀名
			temp = c_save_path + ".png";  // 原名

			HTuple saveHTuple(c_read_path.c_str());  // 保存图片的路径信息


			//  读取图片
			ReadImage(&ho_Image, saveHTuple.S());
			
			// 获取图片信息
			GetImageSize(ho_Image, &hv_Width, &hv_Height);  // 宽和高
			//整体面积计算
			AreaCenter(ho_Image, &hv_Area, &hv_Row1, &hv_Column1);

			ho_ImageMean = meanImage(c_save_path, ho_Image);  // 先对输入图像进行滤波
			switch (model)
			{
				//模式1，表示对Concrete类的处理
			case 1: concrete(c_save_path, ho_Image, hv_Width, hv_Height); break;
				//模式2，表示对Rebar_concrete的处理
			case 2: rebarConcrete(c_save_path, ho_Image, hv_Width, hv_Height); break;
				//模式3，表示对Rebar_rock类的处理
			case 3: rebarRock(c_save_path, ho_Image, hv_Width, hv_Height);  break;
				
				//模式4，表示对Rebar_rock_concrete类的处理
			case 4:	rebarRockConcrete(c_save_path, ho_ImageMean, hv_Width, hv_Height); break;

			//模式5，表示对Rock类的处理
			case 5: rock(c_save_path, ho_ImageMean, hv_Width, hv_Height); break;
			default: throw "Model Error";
			}
			switch (choice)
			{
				// 选项0：全部实现所有功能
			case 0:
			{

				// 对图像先滤波再阈值化并保存

				binaryMeanImage(c_save_path, ho_Image);

				// 对图形先滤波再阈值化，最后形态学分析并保存

				blobBinaryMeanImage(c_save_path, ho_Image);

				// 计算灰度直方图
				histo(c_save_path, ho_Image);

				// 颜色空间转换
				rgbToHsv(c_save_path, ho_ImageMean, ho_Hue, ho_Saturation, ho_Intensity, 1);

				// Hue分量处理
				binaryHue(c_save_path, ho_Hue, hv_Area, hv_Width, hv_Height);

				// Saturation分量处理
				binarySaturation(c_save_path, ho_Saturation, hv_Area, hv_Width, hv_Height);

				// Intensity分理处理
				binaryIntensity(c_save_path, ho_Intensity, hv_Area, hv_Width, hv_Height);

				break;
			}

			//选项1：对图像滤波再阈值化并保存
			case 1: binaryMeanImage(c_save_path, ho_Image); break;
				//选项2：对图像滤波，阈值化，做Blob分析，最后保存
			case 2: blobBinaryMeanImage(c_save_path, ho_Image); break;
				//选项3：颜色空间转换
			case 3: rgbToHsv(c_save_path, ho_ImageMean, ho_Hue, ho_Saturation, ho_Intensity, 1); break;
				//选项4： 对Hue分量处理
			case 4: rgbToHsv(c_save_path, ho_ImageMean, ho_Hue, ho_Saturation, ho_Intensity, 0); binaryHue(c_save_path, ho_Hue, hv_Area, hv_Width, hv_Height); break;
				//选项5，对Saturation分量处理
			case 5: rgbToHsv(c_save_path, ho_ImageMean, ho_Hue, ho_Saturation, ho_Intensity, 0); binarySaturation(c_save_path, ho_Saturation, hv_Area, hv_Width, hv_Height); break;
				//选项6，对Intensity分量处理
			case 6: rgbToHsv(c_save_path, ho_ImageMean, ho_Hue, ho_Saturation, ho_Intensity, 0); binaryIntensity(c_save_path, ho_Intensity, hv_Area, hv_Width, hv_Height); break;
				//选项7，绘制直方图
			case 7: histo(c_save_path, ho_Image); break;

			default: throw choice; break;
			}

			

			



		}


	}
	catch (const char* e)
	{
		cerr << e << endl;
	}
	catch (int e)
	{
		cerr << "choice must be a integer in the range of [0,7]." << endl;
		cerr << "0：表示完成所有操作，滤波、滤波并阈值化、滤波阈值化之后做Blob分析、颜色空间转换、Hue/Saturation/Intensity分量的处理" << endl;
		cerr <<"1：表示仅实现滤波并阈值化" << endl;
		cerr <<"2：表示仅实现滤波阈值化并做Blob分析" << endl;
		cerr <<"3：表示颜色空间转换" << endl;
		cerr <<"4： 对Hue分量处理" << endl;
		cerr <<"5：对Saturation分量处理" << endl;
		cerr <<"6：对Intensity分量处理" << endl;
		cerr <<"7：绘制直方图" << endl;		
		
		cerr << e << " unsatisfied input" << endl;
	}
	catch(...)
	{
		cerr << "Others Error!!!" << endl;
	}





	
	// 得到的文件路径转换到halcon中
	// 将char*与string转换，建立连接 https://blog.csdn.net/cogbee/article/details/8931838
	// 路径转换

	// 依次读取文件

	


}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void* info)
{
	UnlockMutex(gStartMutex);
}

static Herror apple_action(void** parameters)
{
	// Wait until the timer has fired to start processing.
	LockMutex(gStartMutex);
	UnlockMutex(gStartMutex);

	try
	{
		action();
	}
	catch (HException & exception)
	{
		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
			(const char*)exception.ProcName(),
			(const char*)exception.ErrorMessage());
	}

	// Tell the main thread to terminate itself.
	LockMutex(gStartMutex);
	gTerminate = TRUE;
	UnlockMutex(gStartMutex);
	CFRunLoopStop(CFRunLoopGetMain());
	return H_MSG_OK;
}

static int apple_main(int argc, char* argv[])
{
	Herror                error;
	CFRunLoopTimerRef     Timer;
	CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

	CreateMutex("type", "sleep", &gStartMutex);
	LockMutex(gStartMutex);

	error = HpThreadHandleAlloc(&gActionThread);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadHandleAlloc failed: %d\n", error);
		exit(1);
	}

	error = HpThreadCreate(gActionThread, 0, apple_action);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadCreate failed: %d\n", error);
		exit(1);
	}

	Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
		CFAbsoluteTimeGetCurrent(), 0, 0, 0,
		timer_callback, &TimerContext);
	if (!Timer)
	{
		fprintf(stderr, "CFRunLoopTimerCreate failed\n");
		exit(1);
	}
	CFRunLoopAddTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);

	for (;;)
	{
		HBOOL terminate;

		CFRunLoopRun();

		LockMutex(gStartMutex);
		terminate = gTerminate;
		UnlockMutex(gStartMutex);

		if (terminate)
			break;
	}

	CFRunLoopRemoveTimer(CFRunLoopGetCurrent(), Timer, kCFRunLoopCommonModes);
	CFRelease(Timer);

	error = HpThreadHandleFree(gActionThread);
	if (H_MSG_OK != error)
	{
		fprintf(stderr, "HpThreadHandleFree failed: %d\n", error);
		exit(1);
	}

	ClearMutex(gStartMutex);
	return 0;
}
#endif

extern "C" _declspec(dllexport) int main_action(int argc, char* argv[])
{
	int ret = 0;

	try
	{
#if defined(_WIN32)
		SetSystem("use_window_thread", "true");
#elif defined(__linux__) && !defined(__arm__)
		XInitThreads();
#endif

		// Default settings used in HDevelop (can be omitted) 
		SetSystem("width", 512);
		SetSystem("height", 512);

#ifndef __APPLE__
		action(0,0);
#else
		ret = apple_main(argc, argv);
#endif
	}
	catch (HException & exception)
	{
		fprintf(stderr, "  Error #%u in %s: %s\n", exception.ErrorCode(),
			(const char*)exception.ProcName(),
			(const char*)exception.ErrorMessage());
		ret = 1;
	}
	return ret;
}

#endif


#endif


